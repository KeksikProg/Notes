вся нформация из книги 'django 2.1. Практика создания веб-сайтов на python'

НЕКОЕ СОДЕРЖАНИЕ
 - классы полей модели
 - связи
 - методы моделей
 - влидация 
 - коды ошибок в валидаторах
 - модификаторы
 - ответы пользователю
 - получение сведений о запросе
 - ответы пользовтелю 2
 - сокращение
 - декоратры джанго
 - котроллеры классов
 - простешие контроллеры классов
 - примеси в контроллерах классах
 - обобщенные классы
 - классы выводящие список
 - шаблонизаторы
 - директивы
 - теги
 - фильтры
 - наследственность шаблонов
 - статические файлы
 - пагинаторы
 - формы 
 - формы связанные с моделями
 	1. фабрика моделей (на короткий срок)
 	2. быстрое объявление (продолжительный срок)
 	3. полное объявление (расширенный функционал)
 - разграничивание доступа 
 - получение сведений о пользователе
 - авторизация
 - расширенные возможности моделей
 - полиморфные связи
 - наследование шаблонов 
 - создание диспетчеров записей
 - управление транзакциями
 - транзацкии на низком уровне
 - формы без моделей 
 - вывод форм
 - CAPTCHA
 - BBCode
 - Bootstrap
 - создание фильтров и тегов 
 - шаблонные теги
 - ОБАБОТКА ВЫГРУЖЕННЫХ КЛИЕНТОМ ФАЙЛОВ
 - ФАЙЛЫ В МОДЕЛЯХ
 - ОБРАБОТКА ВЫГРУЖЕННЫХ ФАЙЛОВ
 - БИБЛИОТЕКИ
 	- django-cleanup
 	- easy-thumbnails
 	- python auth social
 - модель данных пользователя
 - создание прав






verbose_name - название поля, которое будет высвечиваться при использовании на админ сайте

help_text - текст, который будет дополнительно пояснять, что-нибудь

default - значение, которое будет в поле по умолчанию

unique - если True, то в текущее поле может быть занесено уникальное значение, которое не используется в други полях

unique_for_date - кароче если в этом параметре указать строку с типом datefield или datetimefield, то в нашей строчке где этот параметр можно будет указать дату только из строчки, которая уазывается в параметре

null - если	True, то поле может иметь значение null (не тоже самое, что и пустая строка)

blank - если True, то поле становиться необязаетльным к заполнению

choices - последовательность значений, которые могут быть занесены в этот список
тут все не так просто
каждый элемент должен состоят из 2 значений
то что будет реально заносится в таблицу и то что будет видет пользователь
Пример: class Bb(models.Model):
			Kinds = ((None, 'Выберите действие'),('b', 'Куплю'), ('s', 'Продам'))
в данном случае элемент выберите действие будет некой пустой строкой (если строка необязаетльная к заполнению) а в других случаях если выбрать Куплю, то в базу будет занесено b

db_index - если True, то в таблице а данном поле будет создан индекс

primary_key - если True, то поле будет помеченно ключевым (оно сразу возьмет параметры unique и будет обязательно к заполнению) В ТАБЛИЦЕ МОЖЕТ БЫТЬ ТОЛЬКО 1 КЛЮЧЕВОЕ ПОЛЕ

editable - если True, то поле будет выводиться в форме, если False, то не будет даже если его туда внести
--------------------------КЛАССЫ ПОЛЕЙ МОДЕЛИ------------------------------------------------

          Классы полей моделей - какой тип данных будет храниться в данном поле

CharField - строковый тип ограниченной длины (поддерживает параметр max_length)

TextField - строковый тип, но не ограниченной длинны

EmailField - позволяет корректно сформировать адрес элект. почты (поддерживает параметр max_length)

URLField - корректно сформированный интернет адрес

SlugField - строка, , которая индефицирует запись и используется в интернет адресе

BooleanField - логическое поле, хранящее значение True или False (по умолчанию None) (Поддерживает параметр Null, что дает возможность оставить в поле None)

IntegerField - знаковое целочисленное поле обычной длинны (32 символа)

SmallIntegerField - тоже самое только 16 символов

BigIntegerField - тоже самое только 64 символа

PositiveIntegerField - беззнаковое целочисленное обычной длинны

PositiveSmallIntegerField - то же самое только 16 символов

FloatField - вещественное число

DecimalField - вещественное число с фиксированной точностью (поддерживает параметры max_digits - максимальное количество цифр и decimal_places - максимальное количество цифр после запятой)
-----------------------------СВЯЗИ--------------------------------------------------------

          Связи - это способ взаимодействия одних моделей с другими

связь 'Один со многими', чтобы связать одну первичную модель с множеством вторичных
ForeingKey(<Первичная модель>, on_delete = <Поведение при удалении>, <Остальные параметры>)

если необходимо передать модель из другого приложения, то 
ForeingKey(<название приложения>.<имя класса приложения>, ...)

если нужно создать рекурсивную связь (модель саму на себя), то
ForeingKey(self, ...)

on_delete:

CASCADE - Вместе с первичной мделью удаляет и вторичные
PROTECT - Возбуждает исключение при попытке удалить первичную модель

SET_NULL - если в первичной модели можно поставить null, то это и делает и при удалении

SET_DEFAULT - при попытке удалить первичную модель ставит в поле значение по умолчанию

SET(<Значение>) - при попытке удалить первичную модель в поле заносит значение (можно указать функцию, которая не принимает параметров)

DO_NOTHING - ничего не делает

связь 'один с одним' - в случае, когда одна вторичная модель дополняет другую первичную модель
OneToOneField(<Первичная модель>, on_delete = <Поведение при удалении>, <Остальные параметры>)

связь 'многие со многими' тут все легко для нас, но не для django позволяет связывать произвольное кол-во первичных моделей с производным кол-вом вторичных моделей
для создания такой связи нужно в одной из наших моделей (ИМЕННО В ОДНОЙ НЕ В ДВУХ) объявить 
ManyToManyField(<вторая связываемая модель>, <остальные параметры>)
-------------------------МЕТОДЫ МОДЕЛЕЙ-----------------------------------------------------------

__str__() - возвращает строковое представление модели, (будет выводиться только если в HTML коде указанно, к примеру {{ rubric }}, то есть без атрибутов)

save() - выполняет сохранение записи (обязательно должен быть унаслоедован от класса, к примеру)
def save(self, *args, **kwargs):
	# какие-то действия до сохранения ...
	super().save(*args, **kwargs)
	# какие-то действия после сохранения ...

delete() - как можно было догадаться выполняет удаление записи (также как и с сохранением надо унаследовать от класса)
def delete(self, *args, **kwargs):
	# какие-то действия до сохранения ...
	super().delete(*args, **kwargs)
	# какие-то действия после сохранения ...
---------------------ВАЛИДАЦИЯ--------------------------------------------------------------
          Валидация - проверка данных на корректность



бывают множество видов валидаторов, к примеру с типе CharField сразу используется валидатор MaxLengthValidator , который проверяет строку на длинну символом
также есть: 
MinLengthValidator - проверяет не меньше ли длинна строки допустимиого
MinLengthValidator (<минимальная длинна>, message = <сообщение, которое будет высвечиваться при нарушении условия>)

MaxLengthValidator - проверяет не больше ли длинна строки допустимиого

RegexValidator - проверяет строку на соответствие выражению
RegexValidator (regex = None, message = <>, code = <>, inverse_match = <>, flags = <>)
regex - само регулярное выражение
message - сообщение, которое будет высвечиваться при нарушении
code - код ошибки (по умолчанию 'invalid')
inverse_match - если False, то строка должна соответсвовать выражению (по умолчанию), если True, то наоборот не должна
flag - флаги выражения

EmailValidator - проверяет на корректность заносимый адрес электроной почты 
тут только один параметр интересный
whitelist - последовательность доменов, которые не будут проверятся валидатором 

и ещё куча с 109 и до 112
---------------------------КОДЫ ОШБИОК В ВАЛИДАТОРАХ----------------------------------------^
доступные для указания коды ошибок в валидаторе

код ошибки - это специальынй код, который показывает какая ошибка была совершенна
то есть, к примеру
код 'invalid' - говорит нам о том, что в поле было занесенное неверное значение
и мы можем этот код изменить {'invalid':'Неверно занесенно значение'}

стр 113
--------------------МОДИФИКАТОРЫ-----------------------------------------------
          модификаторы - нужня для того, чтобы при фильтрации записей можно было поставить не точное значение а к примеру меньше больше и т.д.




модификаторы записываются в виде <имя поля>__<модификатор>
пример: 
for b in Bb.obrjects.filter(price__lt = 10000) - price__lt это модификатор, котоырй говорит, чтобы фильтр искал все значения ценой меньше 10000 
все мадификаторы на странице 141-142

также если у нас вдруг связанные модели, то можно выполнить поиск так 
<имя поля внешнего ключа>__<имя поля первичной модели (ключа)>
пример:

for b in Bb.objects.filter(rubric__name = 'Недвижимость'): ... - мы в вторичной моедли ищем значения из первичной

можно также сделать наоборот <имя вторичной модели>__<имя поля вторичной модели>
пример:
for r in Rubric.objects.filter(bb__price__gt = 1000): ... - иы в поиске первичной модели ищем значения из вторичной

при фильтрации в классе Q, чтобы обозначить логические операторы
~ - это НЕ \
| - это ИЛИ | - это все логические операторы 
& - это И  /
пример:
from django.db.models import Q
q = Q(rubric__name = 'Недвижимость') | Q(rubric__name) = 'Транспорт')

for b in Bb.objects.filter(q): ... - то есть сделать, что-то со всеми записями где рубрика это недвижимость ИЛИ транспорт

уникальность при фильтрации страница 145

в джанго так же есть агрегатные функции, которые производят вычисления во значениях определенного поля в модели (то есть делает вычисления в столбиках)

чтобы сделать агрегатню функцию надо ввести метод aggregate(<агрегатная функция 1>, < агрегатнся функция 2>, ...)
агрегатная функция создает словарь в котором ключ это <поле к которому применятеся агрегатная функция>__<агрегатная функция>
пример:
from django.db.models import Min
Bb.objects.aggregate(Min('price'))

в случае если нам надо провести отдельное агрегатное вычесление по определенным полям , сформированых по определенному притерию, то лучше стоит использовать функцию annotate(<агрегатная функция 1>,<агрегатная функция 2>...)
-------------------------ОТВЕТЫ ПОЛЬЗОВАТЕЛЮ---------------------------------------------------------
классы ответа, который поддерживают контроллеры на странице 174
по сути, сформировать ответ на запрос пользователся является основной задачей контроллера
самым часто используемым классом ответа является HttpResponse(он может отправлять текст, и веб-страница, которые мало весят)
--------------------ПОЛУЧЕНИЕ СВЕДЕНИЙ О ЗАПРОСЕ--------------------------------------------------------------
получение сведений о запросе:
полученный от пользователя запрос хранится в классе HttpRequest (или просто request)
он хранит различные сведения, которые могут быть полезны в создании ответа 
страница 178
------------------ОТВЕТЫ ПОЛЬЗОВАТЕЛЮ- 2--------------------------------------------^^
также вместо httpresponse который отправлет пользователю небольшую веб-страинцу 
можно использовать:

StreamingHttpResponse - отправляет пользователю веб страницу по отдельности (небольшими порциями) если вдруг веб-страница большая

FileResponse - используется для отправки пользователю файла 

return FileResponse(open(filename, 'rb')) - если открыть файл таким образом, то он будет открыт в браузере
чтобы загрузить файл на локальный компьютер надо использовать параметр as_attachment со значением True

для отправки данных в формате JSON используется JsonResponse
---------------------------------СОКРАЩЕНИЕ---------------------------------------
            Сокращение - это функция производящая сразу несколько задач, которые являются типичными для каждого приложения(сайта)
самым популярным сокращением является 
render - эта функция рендерит данные (то есть соотносит шаблон и данные, которые должны использоваться в этом шаблоне)
далее
redirect - создает URL отталкиваясь от параметров

get_object_or_404 - как можно понять ищет объект и отправляет его пользовтелю, а в случае неудачи возбуждает ошибку 404 (не найдено)

get_list_or_404 - делает то же самое, только возвращает список с какими либо условиями фильтрации, а не один объект
--------------------------ДЕКОРАТОРЫ DJANGO---------------------------------------
у джанго есть пару декораторов, которые позволяют настроить контроллеры функции(классы)
@require_http_methods - разрешает для контроллера только те методы, которые перечисленны в последовательности 
@require_get - разрешает для контроллера только метод GET
@require_post - разрешает для контроллера только метод POST
@require_safe - разрешает для контроллера только методы GET и HEAD (тк они не изменяют внутренние данные сайта и считаются безопасными)

также есть декоратор @gzip_page - который сжимает страницу по алгоритму GZIP, но его поддерживают не все браузеры 
---------------------------КОНТРОЛЛЕРЫ КЛАССОВ------------------------------------
тоже самое, что и контроллеры функции, но как можно понять, реализованны в виде классов, это инструменты более высокго уровня и некоторые вещи они реализуют самостоятельно
основная часть функция котроллеров классов реализованна в ПРИМЕСЯХ (классы, которые предназначены лишь для расширения других классов)

контроллер класс записывает не как контроллер функция в представлении (views.py) , а с помощью метода as_view(). В методе as_view() можно указать параметры контроллеров класса 
также задать переменные класса можно с помощью создания другого класса, который по наследованию, принимает в себя все от класса. Такой подход иногда радикально меняет методы классов, так что и используют его чаще
------------------------------ПРОСТЕЙШИЕ КОНТРОЛЛЕРЫ КЛАССЫ-----------------------
View - этот класс, всего лишь определяет HTTP метод с помощью которого был выполнен запрос (этот класс довольно редко просто так используют. Обычно используют производные от него классы)
------------------------------ПРИМЕСИ----------------------------------------------
Примесь ContextMixin
(Я надеюсь мы помним, что такое примесь, а если нет, то строчка 228)
данная примесь добавляет классу средства создавать конекст шаблона, но их немного
  
extra_context - атрибут задающий контекст шаблона, его значение должно быть представленно в виде словаря 

get_context_data - элемент должен создавать и возвращать контекст данных

TemplateResponseMix - примесь, которая добавляет наследющему классу средства для рендеринга шаблона

поддерживает слудющие атрибуты и методы:

template_name - атрибут, задающий путь к шаблону в виде строки ('bboard/index.html' пример)

get_template_names - метод, который возвращает пути к шаблонам

content_type - атрибут, задающий MIME-тип и его коидрвку

render_to_response(<контекст шаблона>) - возвращает отрендеренный шаблон в виде класса TemplateResponse

класс TemplateView наследует все выше сказанные классы 
---------------------------ОБОБЩЕННЫЕ КЛАССЫ-----------------------------------------
это классы, которые выполнят типовые задачи и могут быть использованы в различных ситуациях

примесь SingleObjectMixin - это класс наследющий от ContextMixin, он самостоятельно извлекает записи из модели, по значению её ключа, которые в свою очередь получает из URL параметра 
там много методов и атрибутов, так что все на странице 192

примесь SingleObjectTemplateResponseMix - класс, который, выполняет рендеринг шаблона на основне найденной в записи модели, там тоже много атрибутов и методов, так что все на странице 194

и конечно же класс контроллер DetailView, который содержит в себе классы View, TemplateResponseMix, SingleObjectMixin, SingleObjectTemplateResponseMix

данный котроллер сам ищет запись по значению ключа, заности её в атрибут object и выводит на экран страницу со сведениями о данной записи
--------------------------КЛАССЫ ВЫВОДЯЩИЕ СПИСКИ-------------------------------------
Примесь MultipleObjectMixin - класс, который может производить действия, с некоторыми списками данных, которые могут быть отфильтрованны по какому либо условию 
там так же много атрибутов и методов, так что все на странице 197
-----------------------------ШАБЛОНИЗАТОРЫ--------------------------------------------
Шаблон - образец для форимарования веб страница, которая будет отправлена пользователю
Шаблонизатор - подсистема фремворка, которая формирует окончательный вид веб-страинцы
-----------------------------ДИРЕКТИВЫ------------------------------------------------
Директивый - применяются для вывода данных в коде шаблона и записываются в виде 
{{ <переменная из контекста шаблона> }}
в директиве можно обращаться к:
1. к переменной из последовательности {{ bb.0 }} (возьмет значение из последовательности у которой индекс 0)
2. извлекать элемент словаря по ключу {{ bb.kind }} (извлечь значение из словаря с ключом kind)
3. обращаться к атрибутам {{ bb.rubric_name }}
4. вызывать методы, которые не требуют параметров {{ rubric.get_url }}
--------------------------ТЕГИ--------------------------------------------------------
джанго поддерживает различные теги, которые управляют генерированием результата документа записывается в виде:
{% <тег со всеми необходимыми данными> %}
в джанго как и в html есть одинарные и парные теги
пример одинарного: {% csrf_token %} - вставляет в нужное место токен, который используется подсистемами безопасности джанго
пример парного токена: {% for ... in ... %}<какая либо информация>{% endfor %}

Теги поддерживаемые шаблонизатором джанго:

url <имя маршрута> <список значений> - формирует интернет адрес посредством обратного разрешения

for ... in ... endfor - действует как обычный for в python, только одна особенность
посреди for можно вставить тег {% empty %}, который будет выводить что либо если последовательность пустая
в содержимом можно использовать ещё некоторый набор переменных, но он большой, так что все на странице 226

if ... elif ... else ... endif - то же самое, что и условный оператор if в обычном python 

ifchanged ... endifchanged - выводит элементы, только если они были изменены в прошлоый итерации

cycle - последовательно помещает в шаблон значения из последовательности, а когда они заканчиваются перебор начинается сначала (размер последовательности не ограничен)

resetcycle [название cycle]- сбрасывает тег cycle, (по умолчанию сбрасывает последний тег в шаблоне), если нужно указать точный тег cycle, который надо сбросить, то ему назначается переменная с помощью as и ставится перед нашим тегом

firstof <спиосок значений> - вставить в шаблон первое не пустое значение из списка значений

with <набор операций присваиванияБ который разделенны пробелом> ... endwith - заносит какие-либо значения в переменные для дальнейшего использования (они сразу могут использоваться в данном шаблоне)

regroup <последовательность> by <ключ элемента или атрибут> as <переменная> - группирует элементы из последовательности по ключу элемента или атрибуту и заносит в новую переменную

now <формат> - вставляет в шаблон текущую дату и время согласно заданному формату

filter <фильтр или фильтры> ... endfilter - применяет к содержимому указанные фильтры

csrf_token - вставляет в шаблон специальный токен, который помогает джанго обеспеивать безопасность сайта (используется исключительно в веб формах (<form>))

spaceless ... endspaceless - удаляет пробельные символы (табуляции, перенос каретки и тд) между своими тегами 

templatetag <обозначение последовательности символов> - вставялет в шаблон символы, которые по другому туда не помесить ({#,#}, {%,%}, {{, }} и тд)

verbatim ... endverbatim - вставляет в шаблон содержимое как есть, без обработки тегов, директив и тд

load <список библиотек, разделенных пробелами> - загружает в шаблон библиотеку тегов (должно быть первым тегом во всем шаблоне)

widthratio <текущее значение> <максимальное значение> <максимальная ширина> - применяется для создания диограмм

comment <заголовок> ... endcomment - добавляет в код шаблона комментарий, который не обрабатывает щаблонизатором (если комментарий занимает всего одну строку можно воспользоваться тегом {# ... #})

debug - выводит на странице разнообразную отладочную информацию (на практике, как говорит автор, не очень полезно)
-----------------------ФИЛЬТРЫ---------------------------------------------------------
Фильтры - выполняют определенные преобразования значений перел их выводом 
фильтр записывает внутри директиве ({{ }}) с помощью вертикальной черты (|)
пример:
{{ bb.published|date:'d.m.Y H:i:s' }}

фильтры можно также объеденять в несколько (они будут выполнятся слева направо)
пример:
{{ bb.content | default:'--описания нет--' }} - в случае если в переменной bb.content ничего не будет, то высветится надпись 'описания нет'

список фильтров, которые поддерживает джанго:
date: <формат даты и времени> - формирует значение даты и времени отталкиваясь от формата (все форматы заданны на странице 231)

time: <формат времени> - делает то же самое что и выше , но только время 

timesince: <значение для сравнения> - это уже поинтереснее, в общем, выводит промежуток времени разделяющий выводимое значение даты и времени и заданное число я сравнения 

timeuntil: <значение для сравнения> - то же самое, что и выше, только значение для сравнения должно находиться в прошлом времени

yesno: <строка образцов> - преобразует такие значения как True False или None в слова 'да', 'нет' или 'может быть', также можно записать свои слова в строке образцов (если для None не задано будет, то будет брать у False)

default: <значение> - будет выводить значение если в переменной не указанно

default_if_none - тоже самое, но будет выводить значение только в том случае если в переменной именно None

upper - делает все буквы в верхний регистр

lower - делает все буквы в нижний регистр

capfirst - делает первую букву выводимого значения в верхний регистр

title - делает каждую первую букву слова в верхний регистр

truncatechars: <длина> - обрезает слово до назначенной длинны и ставит в конец слова '...'

truncatechars_html: <длина> - делает то же самое, но сохраняет все html теги 

truncatewords: <кол-во слов> - обрезает значение до кол-во слов и в конец ставит ...

wordwarp: <величина> - выполняет перенос всех строк таким образом, чтобы ни одни строка не превышала величину

cut: <подстрока> - удаляет из выводимого значения все вхождения подстроки

slugify - преобразует значение в слаг

stringformat <формат> - форматирует выводимое значение согласно формату

floatformat: <кол-во после запятой> - округляет вещественное число, до кол-во после запятой

там ещё много фильтров все можно посмотреть на страницах (231-238)
-------------------------НАСЛЕДСТВЕННОСТЬ ШАБЛОНОВ---------------------------------------------
Наследственность в шаблонах джанго такая же как и у классов питона, то есть, то что есть у базового шаблона будет и у всех шаблонов, которые наследуются от него
также в базовом шаблоне могут быть блоки
Блоки - код в базовом шаблоне, в который каждый последующий шаблон поместит свою уникальню информацию (блоков модет быть сколько угодно)
блоки обозначаюся парным тегом 
{% block <имя блока> %}...{% endblock %} (у всех шаблонов наследющих данный блок, должно быть одиннаковое имя одного и того же блока)
пример:
{% block title %}Главная{% endblock %} (имя блока можно записывать и в закрывающем теге, но это не обязательно)
в коде шаблона нужно указать, что он является производным от другого шаблона, это делается с помощью тега
{% extends <путь к базовому шаблону> %} (как я уже говорил выше, тег extends должен находиться в самом верху и это должен быть самый первый тег во всем коде)

после объявления базового шаблона можно объявлять блоки, занося в них уникальное содержимое

если в прооизводном шаблоне не указать инфу в каком либо блоке, он возьмет информацию из базового шаблона

если вместе с уникальной информацией в блоке нужно вывести инфу из базового шаблона, то это делается с помощью директивы {{ block.super }} внутри блока в том месте где нам нужна инфа

также уже производные от какого либо шаблона можно сделать базовыми ещё для других шаблонов 
--------------------------------------СТАТИЧЕСКИЕ ФАЙЛЫ-------------------------------
статические файлы - это файлы, которые отправляются пользователю без обработки такие как CSS, фотки, аудио и видео
загружать статические файлы в код шаблона можно несколькими способами 
1. загружаем библиотеку тегов static ({% load static %})
и потом в тег html <link> вставляем статические файлы 
пример:
{% load static %}
...
<link ... href = '{% static <путь к статичным файлам> %}'>
...
там есть другие способы вставить статичные файлы, но я из считаю бесполезными
--------------------ПАГИНАТОРЫ-------------------------------------------------------
Пагинатор - механизм, который занимается разделением больштх списков на отдельные части
смысл использовать пагинатор есть только в контроллерах функция и классах контроллерах простейшего уровня, другие классы контроллеры используют пагинатор неявно сами

чтобы сделать пагинатор надо вызвать класс Paginator и сделать экземпляр
как сделать пагинатор на странице 243
у пагинатора есть 2 метода 

get_page(<номер части>) - возвращает указанный номер части 

page(<номер части>) - делает тоже самое, но оставлен для совместимости с прошлыми частями джанго
---------------------ФОРМЫ-------------------------------------------------------
Форма - это некоторая сущность для получения данных от пользователся и проверка их на корректность
----------------------ФОРМЫ СВЯЗАННЫЕ С МОДЕЛЯМИ---------------------------------
Формы связанные с моделями - это форма, которые после заполнения данных пользователем,
с помощью метода save() сразу заносят их в уже (не)существующую модель
есть несколько способо создать форму связанную с моделями 2 легких и 1 сложный
	1. фабрика форм с моделями 
использовать функцию modelform_factory(<модель>,
[fields = ...,
exclude = ...,
labels = ...,
help_text = ...,
error_message = ...,
field_classes = ...,
widgets = ...,
form = <форма связанная с моделью>])
fields - используется для создания полей модели, надо перечислить (любые поля не включенные в этот параметр не будут занесенны в поле)

exclude - делает то же самое только наоборот поля перечисленные тут не войдут в модель (и так же наоборот все не названные войдут в модель)
!В ВЫЗОВЕ ФУНКЦИИ ДОЛЖНО ПРИСУТСТВОВАТЬ ТОЛЬКО ОДНО ЗНАЧНИЕ ЛИБО FIELDS, ЛИБО EXCLUDE

labels - задает надписи для полей формы. значения должны быть перечисленны в виде словаря, ключами которого являются поля

help_text = указывает дополнительный поясняющий текст для формы (тоже словарь ключи поля, а значения поясняющие)

error_messages = указывает строковые сообщения об оштбках (словарь где ключ поле а значение ещё один словарь с ключом кодом ошибки а значение текст)

field_classes = указывает на то поле какого типа должно быть создано в модели (словарь где ключ поле, а значение класс типа модели)

widgets = позволяет задать для полей элементы управления (словарь ключ поле, а значение метод управления)

forms - указывает на то по примеру какой модели должна будет создаться новая модель

создание форм с помощью фабрик классов стоит использовать когда форма используется редко

	2. создание форм путем быстрого объявления
в данном случае форма создается если она нам нужна на продолжительный срок

класс формы связанной с оделью должен быть производным от класса ModelForm там же объявляется вложенный класс Meta в котором записывается набор атрибутов класса (точно такие же как и у modelform_factory()) (весь пример на странице 250 (у нас в первом проекте немного не так))

	3. способ полное объявление 
в прошлых двух способах есть один недостаток, они предоставляли весьма маленьки набор функций, если же мы хотим получить доступ ко всем атрибутам, то придётся задействовать сложный метод,
который называется прием полного объявления
создание полной формы схоже с обычным созданием модели мы просто заного описываем поля, которые должны быть в форме (пример смотреть на странице 251)
!ЕСЛИ В КЛАССЕ ФОРМЫ ОБЪЯВЛЕННЫ ПОЛЯ И С ПОМОЩЬЮ ПОЛНОГО И С ПОМОЩЬЮ БЫСТРОГО ОБЪЯВЛЕНИЯ, ТО ОБРАБОТАЮТСЯ ТОЛЬКО ТЕ КОТОРЫЕ ПОЛНЫЕ

также при полном объявлении можно задать поля, которых нет в модели 

щас будут относительно короткий список параметров поддерживаемых всеми типами полей при полном объявлении

label - название поля (если не указано возьмет имя текущего поля)

help_text - как уже говорилось выше, делает текст подсказки если можно так выразиться

label_suffix - суффикс суффикс, который будет добавлен к названию поля 

initial - начальное значение поля (если не указан не будет начального значения)

required - если True, в это поле должно быть обязательно занесенно значение есди False, то нет

widget - элемент управления полем, которым поле будет представлятся на веб странице

validators - валидаторы, которые будут у текущего поля 

error_messages - сообщения об ошибках

disabled - если True, то соответствующий для текущего поля элемент управления будет недоступен, а если False, то будет доступен

для форм, большая часть классов полей такая же как и у классов моделей, так что перечислять я их не буду если интересно все на странице 253

в джанго есть различные элемены управления полями ввода, которые записываются в параметре widget
вот некоторые из них:
TextInput - обычное поле для ввода

NumberInput - поле для ввода чисел

EmailInput - поле для ввода адреса электроной почты

URLInput - поле для ввода интрнет адреса 

PasswordInput - поле для ввода паролей 

HiddenInput - скрытое поле

DateInput - поле для ввода даты 

SelectDateWidget - тоже самое что и выше, только дата выбирается с помощью выезжающего списка 

DateTimeInput - поле для ввода и времени и даты

SplitDateTimeWidget - ввод времени и даты в разные поля

TimeInput - поле для ввода только времени

TextArea - область редактирования

CheckboxInput - флажок

Select - список 

RadioSelect - тоже самое что и выше, только выводится как группы переключателей 

SelectMultiple - тот же самый Select, но позволяет выбрать несколько пунктов 

NullBooleanSelect - список с вариантами 'да','нет','неизвестно'
-------------------ВЫВОД ФОРМ-----------------------------------------------------
чтобы вывести форму на веб-страницу есть несколько способов
один из них это метод: as_p() который выводит, поле и его элементы управления в отдельных абзацах
пример:
<form method = 'post'>
	{% csrf_token %}
	{{ form.as_p }} # Тут будет выведенна форма по абзацам
	<input type = 'submit' value = 'Добавить'>
</form>

следющий метод: as_ul() - выводит в виде маркированного списка 

as_table() - вывод в виде таблицы (слева названия, а справа поля)
-----------------------РАСШИРЕННЫЙ ВЫВОД-------------------------------------------
Чаще всего обычный вывод формы фреймворка выглядит неаккуратно, но это можно исправить
можно использовать расширенный вывод, которые позволяет располагать элементы так как нравиться нам, а не фреймворку
для этого используется класс ModelForm, который предоставляет форму и можно с помощью словаря где ключ это название поля, а значение экземпляр класса BoundField
----------------------РАЗГРАНИЧЕНИЕ ДОСТУПА----------------------------------------
один из пользователей, который сразу создается в системе джанго, это, так называемый, суперпользователь, который имеет доступ ко всем закромкам сайты, то есть админ
для создания суперпользователя в консоли (находясь в папке проекта) пишем:
python manage.py createsuperuser

после этого запросится логин (username), который мы будем использовать, а также электроная почта и пароль

тобы сменить пароль, нужно:
python manage.py changepassword <пользователь>

при добавлении пользовтеля будет список, что им можно будет делать, а что нет
там сначала всего 4 действия

view(просмотр)
add(добавление)
change(изменение)
delete(удаление)

на сайтах где довольно много зарегистрированных пользователей используются группы
группы это то место куда заносятся все пользователи с одинаковыми правами и привилегиями

для разлчиных операций исользуются контроллер, вот несколько из них:

	LoginView - контроллер класс, которые выполняет вход на сайт, если успешно, то берет адрес из параметра и перенаправляет, если нет, то просто страница выводится снова страница 293
атрибуты:

template_name = путь к шаблону с страницой входа (по умолчанию 'registration/login.html')

redirect_field_name = имя GET, POST параметра из которого будет браться адрес для перевода после успешного входа

redirect_authenticated_user = если True, то пользователь, который уже зарегестрировался не сможет попасть на страницу входа и будет перенапревлен как в атрибуте выше, а если False, то сможет

extra_context - дополнительное содержимое, которое надо будет добавить в контекст (словарь)

success_url_allowed_hosts - множество хостов в которым у пользователся будет доступ после входа на сайт

authentication_form - ссылка на класс формы входа 

странице входа в составе контекста передаются следующие переменные
 
form - форма для ввода имени и пароля 

next - адрес куда будет выполнено перенаправление после успешного входа на сайт

чтобы добавить реализацию аунтефикации на наш сайт надо просто в маршруты добавить код
path('accaunts/login/', LoginView.as_view(), name = 'login')

	LogoutView - котроллер, который осуществляет выход с сайта страница 295

	PasswordChangeView - контроллер, который осуществляет смену пароля у пользователя(выводит форму с полями, гду нужно ввести старый пароль и 2 раза новый (для надежности)) страница 297

	PasswordChangeDoneView - контроллер, который просто выводит страницу с сообщением об успешной смене пароля страница 297

	PasswordResetView - контроллер, который помогает сбросить пароль, (выводит форму, где пользователь должен ввести адрес элентронной почты, и если есть в списке такая, то отправляет письмо) страница 298

тут есть пара необычных атрибутов, которых нет в прошлых

subject_template_name - путь к шаблону темы письма

email_template_name - путь к шаблону тела письма 

html_email_template_name - путь к шаблону тела письма в формате html

from_email - адрес куда будет отправлено письмо (по умолчанию берется из DEFAULT_FROM_EMAIL)

form_class - ссылка на класс формы для введения почты

	PasswordResetDoneView - контроллер для вывода сообщения об успешной отправке письма

	PasswordResetConfirmView - контроллер, который как раз и выполняет сброс пароля, он запускается при переходе из письма

------------------------ПОЛУЧЕНИЕ СВЕДЕНИЙ О ПОЛЬЗОВАТЕЛЕ-----------------------------
Любой зарегестрированный пользователь представляется в джанго экземпляром класса User
User - это отдельная модель со своими полями 

доступ к экземпляру User мы можем получить двумя способами:
1. в контроллере из атрибута user класса Request
пример: request.user.is_authenticated (проверить вошёл ли юзер) 

2. в шаблоне через переменную user
пример: {% if user.is_authenticated %} (проверить вошёл ли пользователь в сеть)

начнем знакомство с полей экземпляра user

username - никнейм юзера

password - пароль юзера

email - почта юзера

first_name - имя юзера

last_name - фамилия юзера

is_active - является ли юзер активным (типо если не активный это равно удаленный, но только не удаленный)

if_staff - является ли юзер персоналом (имеет доступ к административному сайту)

is_superuser - является ли юзер суперюзером (имеет все привилегии и является по сути админом)

groups - список групп в которых состоит юзер

last_login - когда последний раз регестрировался

date_joined - когда зарегестрировался на сайте

из полезных атрибутов экземпляр User имеет всего 2:
.is_authenticated - возвращает True если юзер вошёл в сеть

.is_anonymos - возвращает True если юзер не вошёл в сеть

теперь рассмотрим методы экземпляра user

has_perms - возвращает True если пользователь имеет право
право - это право на какое либо действие из строки формата '<приложение>.<операция>_<модель>'
пример: if request.user.has_perm('bboard.add_rubric') # вернет True если User имеет право на добавление новых рубрик (в случае если юзер не активен, то всегда возвращает False)

get_username() - возвращает имя, которое юзер вводит для входа на сайт(логин)

get_full_name() - возвращает настоящие имя и фамилию человека через пробел

get_short_name() - возвращает только настоящее имя юзера
------------------------АВТОРИЗАЦИЯ--------------------------------------------------
Но вот ситуация, мы не хотим допускать юзера на страницу если он, к примеру, не вошёл на сайт, что можно сделать в таком случае

Императивный способ:
Он довольно простой, мы просто указываем Django что делать если юзер не вошёл на сайт или не имеет нужных привелегий

Декларативный способ:
Но этот способ езё легче, мы просто подстравиваем проход на сайт под какие либо критерии, и если юзер их соблюдает он может легко зайти на страницу

в декларативном способе использются декораторы джанго
эти декораторы указываются у контроллеров, которые выводят страницы, которые мы хотим ограничить 

@login_required - допускает к странице только тех пользователей, которые пошли на сайт 

@user_passes_test(<функция>) - допускает в странице, только тех юзеров, которые вошли на сайт и прошли тест из функции и она вернула True
пример:
@user_passes_test(lambda user: user.is_staff) # Допустит к контроллеру только тех, кто является персоналом 

@permission_required(<права>) - допускает к странице только тех юзер, которые соответствуют заданным правам
пример:
@permission_required('bboard/view_rubric') # Допустит к странице, только тех пользователей, которые могут смотреть рубрики

в декларативном способе есть ещё 3 класса-ПРИМЕСИ ,которые помогут с авторизацией, все они являются производными от класса AccessMixin и имею кучу атрибутов, все они на странице 308


(ЕСЛИ КТО ЗАБЫЛ КЛАССЫ ПРИМЕСИ НЕ ДОЛЖНЫ БЫТЬ САМОСТОЯТЕЛЬНЫМИ, ОНИ ИДУТ В СУПЕРКЛАССАХ)


1. LoginRequiredMixin - допускает к странице, только тех, кто авторизовался 

2. UserPassesTestMixin - допускает к сайту только тех, кто выполнил вход и прошёл переделанный тест-функцию test_func() (обязательно нужно переделать, тк обычная возбуждает исключение)

3. PermissionRequiredMixin - допускает к странице, только тех кто имеет нужные права

---------------------------РАСШИРЕННЫЕ ВОЗМОЖНОСТИ МОДЕЛЕЙ-----------------------------
select_related(<поле внешнего ключа>) - (используется в моделях со связью один со многими и один с одним) - позволяет уменьшить использование оперативной памяти и не обращаться к базе данных через первичную модель к вторичной 

b = Bb.objects.get(pk = 1)
b.title # Тут все нормально мы просто обращаемя к уже записанной записи

b.rubric.name # А тут уже не нормально мы 2 раза обращаемся к базе данных сначала за b, а потом за rubric

чтобы такого не было мы делаем по другому
b = Bb.objects.select_related('rubric').get(pk = 1) # Тут ве нормально мы один раз обращаемя и не засоряем память

b.rubric.name # все хорошо

prefetch_related(<связь 1><связь 2><связь 3>) - при использовании с первичной моделью позволяет извлечь все записи связанной вторичной модели

defer(<имя поля 1>...) - указывает не извлекать указанные поля, то есть вот пример

bb = Bb.objects.defer('content').get(pk = 1)
bb.title # извлечено в текущем запросе
bb.content # будет извлечено во 2 запросе, тк указано в defer

only(<имя поля 1>...) - как дефер, только наоборот, то есть указываешь, только те поля, которые надо извлечь, а все остальные извлекаются в отдельных запросах

---------------ПОЛИМОРФНЫЕ СВЯЗИ-------------------------------------------------------
Полиморфной или обощенной называется связь, которая позволяет связать запись из вторичной модели с любой записью из любой модели
----------------------------------НАСЛЕДОВАНИЕ ШАБЛОНОВ--------------------------------
Модель в джанго это обычный класс python, а это значит, что они имеют способность наследственность. Фреймворк предлагает аж 3 способа наследования

	1. Прямое наследование
class Message(models.Model):
	content = models.TextField()

class PrivateMessage(Message):
	user = models.ForeignKey(User, on_delete = models.CASCADE)

В таком случает джанго на основе этих моделей создать таблицы, которые включают только те поля, которые есть в моделях

и установит между моделями связть один с одним, где базовая модель (Message) станет первичной, а производная (PrivateMessage) станет вторичной

прямое наследование может выручить, когда в моделях примерно одинаковые поля и тогда поля общие для обеих моделей заносим в базочую модель, а для уникальных полей заносим в производную модель

	2. Абстрактные модели
чтобы объявить модель абстрактной, надо в её классе Meta атрибуту abstract назначить True (абстрактная модель будет являтся базовой)

если таблица является абстрактной, то для неё в базе данных не будет выделенно таблиц, то есть по сути в базе данных её существовать не будет

но когда мы создаем производную модель от этой абстрактной модели, то в базе данных появляются поля и абстрактной и производной модели
(класс Meta не наследуется от абстрактной модели, но это можно сделать самому, просто в производной модели классу Meta в суперклассах назначаем <абстрактная модель.Meta>)

наследование с абстрактными моделями требуется в тех же слуаях где и прямое наследование, просто оно дает больше возможностей (изменять или удалять поля) и так же выполняется быстрее, тк обращается к одной модели, а не к двум

	3. Прокси-модели
прокси модели использются когда надо увеличить не кол-во полей в модели, а когда надо увеличить функциональность базовой модели
чтобы создать прокси модель надо в ПРОИЗВОДНОЙ модели в классе Meta атрибуту proxy присводить значение True

--------------------------СОЗДАНИЕ ДИСПЕТЧЕРОВ ЗАПИСЕЙ---------------------------------
Диспетчер записей - это объект предоставляющий доступ к набору записей в модели (по умолчанию это objects)
---------------------------УПРАВЛЕНИЕ ТРАНЗАКЦИЯМИ-------------------------------------
Транзакция - это механизм, который вности изменения одновременно в несколько моделей или осталвяет неизменными все модели в случае ошибки (то есть одна модель изменится а другая нет не может)
этот механимз поддерживается СУБД, но Django дает удобные инструменты для этого

джанго сайт можно настроить на 2 режима обработки транзакций, коротко их можно назвать 'всё','ничего'

	1. ничего(по умолчанию)
Подходит для небольших сайтов, потому что каждый запрос к базе данных производится в отдельной транзакции и каждая запущенная транзакция завершается автоматически (ещё неплохо подходит, когда большая часть запросов, это чтение из базы, и всего 1 на изменение)

	2. всё
режим всё подходит для максималистов, которые хотят, чтобы запросы к базе данных производились одной транзакцией, транзакция запусткается перед началом рабоыт контроллера в данном случае транзакция завержается потверждением (если все прошло без ошибок) или откатом (если ошибки)
чтобы включить режим всё надо в настройках нужной баззы данных в словаре DATABASES поставить переменной ATOMIC_REQUEST значение True
режим все подходит для случаев когда большая часть операций на сайте, это изменение добваление данных хранящихся в базе данных, в этом случае либо в базу будут внесенны все изменение либо никакие

-----------------ТРАНЗАКЦИИ НА НИЗКОМ УРОВНЕ-------------
Помимо высокоуровневых инструментов рассомтренных ранее, транзацкии можно производить на более низких уровнях

к примеру:
если в базе данных включен режим ничего, то в одном из контроллеров можно вызвать режим всё
1. указываем контроллеру, которому надо включть значение всё декоратор @atomic

так же можно и наоборот если на уровне базы данных стоит режим всё, то в контроллере можно включить режим ничего
добавив декоратор @transaction.non_atomic_request

также транзакциями можно управлять вручную, для этого есть пару методов

get_autocommit() - возвращает True если для базы данных включен режим автомат. заврешения транзакций

set_autocommit() - включает или отключает режим автомат. завершения транзакций (True False)

commit() - выполняет потвреждение актвной транзакции

rollback() - выполняет откат активной транзакции

savepoint() - создает новую точку сохранения 

savepoint_commit() - выполняет потверждение точки сохранения

savepoint_rollback() - выполняет откат до точки сохранения 

clean_savepoints() - сбрасывает счетчик, унакальных индефикаторов точек сохранения 

пример:
if form.is_valid():
	try:
		form.save()
		transaction.commit()
	except:
		transaction.rollback()

----------------------ФОРМЫ БЕЗ МОДЕЛЕЙ-----------------------------
Формы не связанные с моделями - это формы, которые не заносят данные в них в базу данных (пример поииск по словам), так и данных, которые будут сохранены но позже, после допольниельной обработки 

создание форм без модели, точное такое же и форм с моделями, но есть пару искючений

форма без модели объявляется как подкласс класса Form(, а не ModelForm, как у форм с моделью)

методы instance() и save() в форме без модели не работают, так как некуда сохранять, что ясно
-----------------ВЫВОД ФОРМ------------------------------
Для указания CSS стилей которые будут примененны к полям есть два атрибута 

required_css_class - имя стилевого класса, которым будут помечатся элементы управления, куда нужно будет обязаетльно ввести значения

error_css_class - имя стилевого класса, который будет применен и элементам управления с некорректными данными 

эти стилевые классы применяются к тегам <p> <li> <tr>
-----------------------CAPTCHA---------------------------
Если данные в форму будут занностится не зарегестрированными пользователями, то стоит обезопасить её от нашествия ботов, для этого используется CAPTCHA, есть много библиотек для капчи, но автор будет использовать django-simple-captcha

устанавливаем капчу (pip install django-simple-captcha)
добавляем в INSTALLED APPS 'captcha'
выполняем миграцию 
и в urls на уровне проекта добавляем path('captcha/', include('captcha.urls'))

использовать качу очень легко, надо просто на одном уровне с полями в форме добавить captcha = CaptchaField()

капча поддерживает много функций, но далее будут самые нужные 

CAPTCHA.CHALLENGE_FUNCT - Полное имя функции, которая генерирует капчу
всего их 3:
1. captcha.helpers.random_char_challenge - классическая капча из 4 букв не реагирующая на регистри

2. captcha.helpers.math_challenge - капча, которая прсоти пользователя решить уравнение

3. captcha.helpers.word_challenge - словарная капча, которая прости вести слво из словаря 

CAPTCHA_LENGTH - длина капча в символах (толкьо к классической)(по умолчанию 4 символа)

CAPTCHA_WORDS_DICRIONARY - путь с словарю (только с кловарной капчей)

и там ещё много, все на стринце 345
---------------------------------BBCode-----------------------------------------------
Библиотека django-precise-bbcode: Поддержка BBCode

BBCode - это специальный язык разметки, котоырй используется, для форматирования текса на многих сайтах

Форматирование выполняется с помощью специальных тегов, которые потом интерпритируются в теги HTML

там достаточно тегов, некоторые повторяют функционал тегов html, так что я покажу, только непохожие

[color = <цвет>]<текст>[/color] - выводит на экран текст указанного цвета
[center]<текст>[/center] - выводит изображение по центру экрана
[code]<текст>[/code] - выводит текст моноширным шрифтом 
остальные теги на странице 350

текст отформатированный тегами BBCode, можно хранить в любом поле, даже в TextField, но если модель пока не заполнена, то лучше выделить под хранение такого текста отдельное поле BBCodeTextField

для вывода содерижмого такого поля следует воспольховаться атрибутом rendered, то есть вот так {{ <модель>.<название поля>.rendered }}

!ПОЛЕ ТИПА BBCodeTextField СТОИТ ОБЪЯВЛЯТЬ ТОЛЬКО В ТЕХ МОДЕЛЯХ, ГДЕ НЕТ НИ ОДНОЙ ЗАПИСИ, А ТО ОНИ ИСЩЕЗНУТ

Дополнительные BBCode теги, созданные разработичном хранятся в модели приложения precise_bbcode

для создания BBCode тега, у него обязательно должно быть 
1. Tag definition - как он будет записывать в тексте между []
2. Replacement HTML code - какому КОДУ HTML соответсвует данный тег

в BBCode параметры указываются внутри открывающего тега и разделяются символом =

и там ещё много свойств, они даны на странице 353 (чтобы было понятно установить флажок это отметить, и сбросить не отмечать, чтобы было понятно)

помимо тегов BBCode там также присутсвует библиотека, которая позваоляет обрабазывать смайлики, к сожалению, с самого начала библиотке пуста и её придётся полнят самому

для каждого смайлика, нужно указат пару сведений

smiley code - текстовое представление смайлика (':)',':(',':-)') и так далее

smiley icon - картинка, которая будет высвечиваться вместо текстового представления смайлика

smiley icon width - ширина смайлика в пикселях(если не указана, то будет использоваться первоначалный)

smiley icon height - длина смайлика в пикселях

данная библиотека прекрасно работает по умолчанию, но знать настройки не помешает, все они указаны на странице 355

-------------------------BOOTSTRAP----------------------------------------------------
Bootstrap - это библиотека для CSS, чтобы легко делать различные штуки, такие как слайдеры, сполйеры и все остальное

так вот библиотека django-bootstrap4, можт управлять библиотекой Bootstrap

там куча тегов все они даны на странице 357
-----------------------СОЗДАНИЕ ТЕГОВ И ФИЛЬТРОВ---------------------------------------
Чтобы создать фильтры и теги, надо на уровне приложения создать папку templatetags и в ней пустой модуль __init__.py

фильтр - это всего лишь код, который:
1. принимает обрабатываемое значение в первом параметре
2. принимает значение параметров указанных у фильтра
3. возвращает обработанное обрабатываемое значение

чтобы объявить наш фильтр надо из django импортировать template и функции, которая должна стать фильтром присваиваем декоратор @template.Library.filter

чтобы создать простейший одинарный тег, то надо сделаь то же самое только вызвать не функцию filter а функцию simple_tag (так же ввиде декоратора )

если мы хотим вставить в шаблон кусок рабочего HTML кода, то нам нужно пропустить в функции через другую функцию mark_safe()
@template.Library.simple_tag
def lst (sep, *args):
	return mark_safe(f'{sep.join(args)} (итого <strong>{len(args)}</strong>') - в данном случае тег strong будет работать

но чаще всего такие легкие теги не требуются, чтобы вставить в шблон более сложный HTML код, то стоит воспользоваться шаблонным тегом
------------------------------ШАБЛОННЫЕ ТЕГИ-------------------------------------------
шаблонные теги - теги, которые создают отдельный шаблон для себя и могут быть вставлены позже в любой другой шаблон 						!ЕСЛИ ВЫ НАРУШИЛИ СОГЛАШЕНИЕ ДЖАНГО О НАХОЖДЕНИИ ТЕГОВ И ФИЛЬТРОВ, ТО КАК ЭТО ИСПРОВАИТЬ НА СТРАНИЦЕ 371
создаются из того же класса, только функцией inclusion_tag(<путь к шаблону>)
--------------------------------ОБАБОТКА ВЫГРУЖЕННЫХ КЛИЕНТОМ ФАЙЛОВ-------------------
Обработчик выгрузки - извлекает файл из отпрвленных поситителме данных и временно сохраняет в оперативной памяти(если меньше 2.5 МБайт) или серверной(если больше 2.5МБайт)

чаще всего пользователи выгружают файл на сервер для того чтобы его могли посмотреть или скачать другие юзеры, а для этого нам нужно создать маршрут на каждый файл
для этого используется функция static(<префикс>, document_root = <путь к папке с файлами>)
эта функция создает маршрут с специальным префиксом, встертиво его джанго передаст пульт управления специальному контроллеру и тот передает файл пользователю
-----------------------------ФАЙЛЫ В МОДЕЛЯХ-------------------------------------------
Автор книги настоятельно рекомендует хранить файлы в моделях (точнее пути к ним), так как это упростить создание сайтов 
для создания файлов м оделях есть всего 2 типа 
1. FileField - для дюбых файлов 
2. ImageField - только дял графических файлов 
-----------------------------ОБРАБОТКА ВЫГРУЖЕННЫХ ФАЙЛОВ------------------------------
В принцпе, обработка файлов происходит также как и других данных, надо иметь в виду только пару моментов 

1. при выводе формы для выгрузки файлов надо указать тип кодировки 'multipart/form-data' - иначе файлы не выгрузятся 

в случае если нам надо выгружать сразу несколько файлов, то можно сделать так
for file in request.FILES.getlist('img')
	img = Img()
	img.desc = form.cleaned_data['desc']
	img.img = file 
	img.save()
-------------------------БИБЛИОТЕКИ----------------------------------------------------
-------------------------DJANGO-CLEANUP------------------------------------------------
Библиотека django-cleanup позволяет не писать тот код который был выше, чтобы удалить файл вместе с моделью, а всего лишь скачать её и записать в INSTALLED APPS и все, он работает
--------------------------EASY-THUMBNAILS----------------------------------------------
easy-thumbnails - библиотека для создания миниатюр
миниаютра - маленькая фотография (пример фотки заказов на авито когда ты ещё не перешёл на заказ, а видишь фотку это миниаютра), то есть уменьшеная копия любой фотки
там много свойств и параметров, так что все на странице 388 и дальше

вывод миниаютр в шаблонах
чтобы вывести миниатюру в шаблоне сначала надо поставить библиотеку с помощью load
{% load thumbnail %}
-------------------------PYTHON-SOCIAL-AUTH--------------------------------------------
Python Social Auth - это специальная библиотека, которая позволяет регестрироваться на сайте с помощью социльных сетей

пример вк:
переходим по ссылке https://vk.com/apps?app=manage
создаем приложение ( назвать можно как угодно )
устанавлваем social-auth-app-django
и добавляем в INSTALLED APPS social_django

там надо будет создать кортеж как это сделать на странице 405 пункт 4

потом записываем в переменные значения id и защищенного ключа нашего приложения
-------------------------------------------------МОДЕЛЬ ДАННЫХ ПОЛЬЗОВАТЕЛЯ-----------------------------------------------------------------
Для хранения данных пользователся джанго использует модель User в ней есть все поля, которые будут нужны в большинстве случаев
Но бывают моменты когда нам нужен к примеру адрес пользователя или номер телефона или что-нибудь ещё 

Можно, в принципе, объявить дополнительную модель со всеми полями, которые нам нужны и соединить в первичной моделью связью 'один-с-одним'
это удобно потому что не будут нарушаться правила разграничения доступа у джанго

однако можно сделать новую модель на основке класса AbstractUser (модель User , тоже построена на этом класса)
и тогда мы не будем создать отельную модель, за нас это сделать джанго (Минус этого способа в том что старые библиотки не обращаются к переменной где хранятся данные о классе модели пользователя, а они напрямую используют класс User, соотвествено дополнительные данные записываться не будут)
-----------------------------------------СОЗДАНИЕ ПРАВ----------------------------------------------------------------------------------------
как мы понмим с самого начала пользователь может получить всего 4 права:
	1. просмотр 
	2. добавление
	3. удаление
	4. изменение
Однако для каждой модели мы можем создать свой собственный набор прав
Это делается в классе Meta в модели с помощью атрибута permossions
---------------------------------ПОСРЕДНИКИ------------------------------
Посредники - это модуль, который обрабатывает запрос клиента до того как он попадет к контроллеру
-----------------------------Cookie--------------------------------------------------
Cookie - это иснтрументы для сохранния каких-либо данных на стороне клиента, есдинственное условие, чтобы данные весии не более 4 кбайт

значения представленные в Cookie в виде строк и представлены только для чтения 

для записи значения в куки есть функция set_cookie()

Также джанго поддерживает Cookie которые дополнительно защищены цифровой подписью
они вызываются точно также только функция set_signed_cookie()
Там теже самые параметры как и врошлом, только один параметр salt(соль) задает особое значение, которое учавствет в создании защиты 
чтобы прочитать такой Cookie надо вызвать функцию get_signed_cookie() и в параметре salt разместить ту же самую соль
----------------------------СЕССИИ----------------------------------------------------
Сессия - это промежуток времени, который начинается с момента захода пользователя на сайт и его выхода оттуда

джанго для каждой сессии генерирует специльаный индефикатор, который сохранятеся на стороне клиента в Cookie файлах и потом если пользователь вернётся к сайту, то сможет продолжить работу с ним

между сессисиоными данными и Cookie данными есть одно главное различие
данные сессии сохрантяются на стороне веб-сервера а Cookie файлы на стророне клиента
-------------------------ВСПЛЫВАЮЩИЕ СООБЩЕНИЯ----------------------------------------
Вслпывающие сообщения существуют только в определенные момент времени и несут ифнормацию акутальную только на данный момент времени 

каждое вслывающее сообщение имеет так называемый уровень или ранг как кому удобнее, он выражается в виде целых чисел

для кажого вроня существует свой стилевой класс 

сначала в джанго есть всего 5 уровней всплывающих сообщений

10 debug - отладосные сообщения для разработчика

20 info - какая либо инофрмация

25 success  - сообщение об успешном действии 

30 warning - сообщение о предупреждении о чем либо

40 error - сообщения о неудачном выполнении каких-либо действий 

для создания сообщений есть много инструментов. В первую очередь это add_message()

также сожно просто сразу вызвать так 
messages.debug|info|success|warning|error(<запрос (request)>, <'Сообщение'>)
--------------------------ОТПРАВКА ЭЛЕКТРОННЫХ СООБЩЕНИЙ-----------------------------
Щас в наше время очень многие сайты отправляют пользователям электронные сообщения по разным темам от новых писем до изменений в статусе купленного товара

на отправку электронных писем влиет весьма много настроек, все они даны на странице 439

Для отправки писем есть как и высокоуровневые стредства так и низкоуровненвые
но использовать низкоуровневые есть смысл только тогда когда в письмах есть вложения 
Класс EmailMessage - обычное элетронное письмо с возможно каким-то вложением (на странице 441)
также письма можно формировать с помощью шаблонов 

Массовая рассылка - для отправки каждого письма мы создаем отедльное SMTP соединение, которое может занят пару секунд, и когда мы отправляем одно письмо с этим можно смириться , но когда происходит массовая рассылка это нехорошо
для этого можно открыть одно соединение и по нему отправлять сразу много писем
get_connection() - получить соединение
get_connection().open() - открыть соединение 
...
email1.send()
email2.send()
...
get_connection().close() - закрыть соединение 

но тут может стать проблемой то что для создания кажого письма ему надо указывать соединение, этого можно избежать просто.
создаем письма без указания соединения
и потом рпосто get_connetion().send_messages([<Тут все письма, которые надо отправить через запятую>])

Высокоуровненвые средства для отправки писем 

django.core.mail:
send_mail() - отправляет одно и то же письмо на разные адреса 

также мы можем отправить письмо зарегестрированному юзеру
email_user()
----------------------КЭШИРОВАНИЕ НА СТРОНЕ КЛИЕНТА-----------------------------------
При получении какой-либо информации веб-обозреватель (браузер) клиента сохраняет страницу в локальный диск, и в случае если страница не изменилась, то просто берет её из кэша уменьшая объем скачиваемой инфы
---------------------------АДМИНИМТРАТИВНЫЙ САЙТ--------------------------------------
Административный сайт - это сайт к которому имеют доступ только суперюзеры и юзеры с правами персонала
на данном сайт можно добавлять, править, удалять какие либо данные
но чтобы это было делать удобнее существуют редакторы модели
Редакторы модели - это класс, который указывает параметры представления модели на административном сайте
Редактор позволит нам задать фильтрацию, как должны выводиться поля модели и многое другое
Класс редактора должен быть производным от класса ModelAdmin
страница списка записей как можно понять выводит какие-то поля из модели, выолнять сортировку, и даже выполнять правку не заходя на запись
--------------------------ДЕЙСТВИЯ-----------------------------------------------------
Действия - в терминологии админ. сайта джанго, действия это некоторые процедуры совершаемые к выбранным спискам записей определенной модели

С самого начала там есть всего одно действие, это удалить выбранные записи <модель>
пример:

def discount(modeladmin, request, queryset):
	f = F('price')
	for rec in queryset:
		rec.price = f / 2
		rec.save()
	modeladmin.message_user(request, 'Действие выполнено!') Всплывающее сообщение, которое говорить о том что действие выполнено
	discount.short_description = 'Уменьшить цену в двое' Название действия 

чтобы зарегестрировать наже действие в редакторе записей надо внутри него в атрибуте actions указать все действия которые мы хотим, чтобы были
----------------DJANGO REST И ВЕБ-СЛУЖБЫ-------------------------------------------------
Многие современные сайты использют веб-службы, мобильные приложения, и просто другие сайты и чтобы получать некоторую ниформацию с них придумали REST архитектуру
джанго тоже поддерживает REST с помощбю библиотеки djangorestframework
также есть библиотека, которая позволяет джанго обрабатвать запрос с любого домена а не только с нашего это библиотека django-cors-headers (все на странице 490)
---------------------СЕРИАЛИЗАТОРЫ-------------------------------------------------------
Сериализаторы - это тоже самое как в и джанго формы только в REST.
Они таже берут некоторые данные из базы по запросу приложения и на их основе составляют поля 

Вывод данных на стороне клиента:
Но вот мы сделали сериализатор, но нам нуэно скачать и декодировать некоторые данные из api, 
как хорошо что уже давно все веб-обозреватели(браузеры) поодежрживают единные инструменты для скачки данных с веб-сервера
такие инструменты используют технологию скачивания AJAX 

------------------------------СРЕДСТВА ДИАГНОСТИКИ----------------------------------------
Средства диагностики применяются для процесса откладки сайта так и для уже опубликованного в сеть сайта на поиск нештатных ситуаций

форматировщик - задает формат в котором будут выводиться сообщения об ошибке (LOGGING в settings.py)

фильтр - отбирает для вывода сообщения которые подходят под некоторые условия

обработчик - непосрелственно выводит сообщения куда-либо (консоль, текстовый файл, ...)

регистраторы - занимаются сбором всех сообщений подстистем джанго 
------------------------------Выкладка сайта на сервер--------------------------------------
Довольно популярный веб-сервер это Apache, так что его мы и будем использовать
Но прежде мы должны сделать пару правок и настроить пару параметров для рабочего сайта
Во-первых, в модуле settings пакета проекта, Во-вторых, отладочный сервер джанго может искать статические файлы в папках пакета приложений, а сервер Apache так не может по этому нам нужно будет собрать все статическе файлы в пакете проекта
это делается так:
STATIC_ROOT = os.path.join(BASE_DIR, 'static') # Мы делаем путь к статическим файлам автоматическим
и потом просто пишем команду
python manage.py collectstatic # Эта команда соберет все статические файлы проекта в одной папке чего и требует Apache

также для уменьшения объема сайта лучше всего очистить ненужные данные (CAPTCHA, сессии, миниатюры)
для все команд используется форма: python manage.py <команда>
captcha_clean - удаляет просроченные капча 
thumbnail_cleanup - удаляет просроченные миниатюры
clearsessions - удаляет сесси 

и в заверешение проверки надо ввести команду python manage.py check, которая проверяет сайт на наличие ошибок.

Далее нам нужно подготовить программный модуль, который будет выступать коннектором между Apache и нашим джанго сайтом 
они находятся на сайте https://www.lfd.uci.edu/~gohlke/pythonlibs/#mod_wsgi
там мы скачиваем файл вида 
mod_wsgi-<версия мода>+ap<версия Apache>vc<версия компилятора с++>-cp<версия питона>-cp<опять версия питона>m-win<разрядность питона>.whl
нам нужно скачать, то что соотвествует версии наешего питона и его разрядности
а потом просто pip install <имя файлы в формате .whl (mod_wsgi...)>

Далее мы скачиваем дистрибутив Apache с сайта https://www.apachelounge.com/download/, который подходит по:
1. коду vc (весрия компилятора в которой был сделан коннектор)
2. разрядность системы (32-бит или 64-бит)

сделав все предварительные действия возвращаемся в командную строку и пишем команду
mod_wsgi-express module-config

Там дальше идет конфигурирование веб-сайта, тут все описывать не буду все на странице 539-541
